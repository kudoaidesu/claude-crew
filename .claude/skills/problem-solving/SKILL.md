---
name: problem-solving
description: 技術的問題・不具合修正の解決手順。公式ドキュメント確認→GitHub Issues検索→実装の順で進める。使用タイミング：バグ修正、不具合修正、問題解決に時間がかかっている時、同じアプローチを繰り返している時、APIが期待通り動作しない時。トリガーワード：「直して」「修正して」「fix」「動かない」「エラーが出る」「なぜか〜しない」「期待通りに動作しない」「原因を調べて」「デバッグ」。
---

# 問題解決手順

## 原則：調査を惜しまない

**迷ったら調べる。自信がなければ調べる。完成度を上げたければ調べる。**

使用ツール：
- **Context7 MCP**: ライブラリの最新ドキュメント取得
- **WebSearch**: ベストプラクティス、UIパターン、既知問題の検索
- **WebFetch**: 公式ドキュメントの詳細確認

---

## 🎯 思考の精度評価と足踏み解消

### 精度が低いサイン（自己チェック）

| サイン | 具体例 | 対処 |
|--------|--------|------|
| 「たぶん」「おそらく」が多い | 「たぶんこれで動くはず」 | テストケースを書く |
| 具体的な例を出せない | 「フィルターが効きます」 | 入力→出力を明示 |
| エッジケースを説明できない | 「複数選択時は？」→「えーと...」 | ユーザーに質問 |
| 代替案と比較できない | 「なぜこの方法？」→沈黙 | 複数案を列挙 |

**2回連続で「たぶん」と言いそうになったら、次のステップに進む。**

### 足踏み時のアプローチ（効果的な順）

```
1. ユーザーに質問（最速・最も正確）
   └─ 「複数選択はありますか？」「この場合どうなるべき？」

2. Codexに聞く（別視点を得る）
   └─ mcp__codex-mcp__codex で気軽に質問
   └─ モデル: gpt-5.2-codex, reasoning: high（必ず最初）
   └─ 解決できなければ reasoning: x-high にエスカレート
   └─ 「この設計で問題ある？」「他のアプローチは？」
   └─ 自分と違う視点・アイデアが得られる

3. 具体的なテストケースを作る
   └─ 入力 → 期待する出力 を3パターン書き出す
   └─ エッジケースを必ず含める

4. 図・表で整理
   └─ データの流れ、Before/After を視覚化
   └─ データ構造の情報欠落をチェック

5. WEB検索
   └─ 「aggregated data filtering SQL」等の類似問題
   └─ ベストプラクティス、設計パターン

6. 小さく実装して検証
   └─ DBクエリだけ先に試す
   └─ モックデータで動作確認
```

### データ設計時の必須チェック

新しいデータ構造を設計する前に確認：

1. **情報の欠落がないか**
   - 集約後に元の関係性を復元できるか？
   - 例: `["1","2","3"]` vs `[["1","2"],["3"]]`（どの要素が同じグループか）

2. **想定ユースケースの網羅**
   - 単一選択 / 複数選択
   - フィルターの組み合わせ
   - 過去データ / 未来データ

3. **テストケースで検証**
   ```
   入力: 団体Aと団体Bで絞り込み、両方出演のイベント
   期待: 1件としてカウント？2件としてカウント？
   → この質問に答えられないなら設計が曖昧
   ```

---

## 🚨 Step 0：Context7でドキュメント確認（必須・スキップ禁止）

**修正を開始する前に、必ずContext7で関連ライブラリのドキュメントを確認する。**

```
1. mcp__context7__resolve-library-id で対象ライブラリを特定
2. mcp__context7__query-docs で問題に関連するAPIを検索
3. 公式の正しい使い方を確認してから修正に着手
```

### なぜ必須か
- 「知っているつもり」のAPIが実は違う仕様だったケースが多発
- Context7は最新ドキュメントを返すため、バージョン差異も把握可能
- 5分の調査で2時間の試行錯誤を防げる

### 確認の流れ

1. **Context7で対象ライブラリの最新ドキュメントを取得**（必須）
2. 使用中のAPIの**正確な仕様**を確認
3. ドキュメントの例と自分のコードを**逐語的に比較**

### チェックリスト
- [ ] パラメータの型は正しいか（相対パス vs 絶対URL等）
- [ ] 必須パラメータは全て指定しているか
- [ ] ドキュメントの例と同じ形式で指定しているか
- [ ] バージョン固有の制約はないか

### 典型的な見落とし
- 相対パスが無視される（絶対URLが必要）
- 環境変数のフォールバックがない
- オプションのネスト構造が異なる

**教訓**: ドキュメントの例が絶対URLなら、まず絶対URLで試す。例をそのまま適用する。

## Step 1：WEB検索で調査（積極的に実行）

Step 0と並行して実行。**迷ったら検索する。**

### 検索すべきタイミング

- 実装方法に自信がない
- ベストプラクティスを知りたい
- UIパターンの参考が欲しい
- エラーの原因が分からない
- 完成度をもっと上げたい

### 検索クエリ例

```
# 問題解決
"[フレームワーク名] [症状] not working"
"[API名] best practices 2025"

# UIデザイン
"calendar UI best practices"
"event card design patterns"
"mobile touch target size guidelines"

# アクセシビリティ
"ARIA [コンポーネント名] pattern"
"WCAG 2.1 [要件]"
```

### 判定

- 同様の報告5件以上 → 既知問題（回避策を探す）
- ベストプラクティス記事あり → 参考にして実装
- 報告なし → プロジェクト固有（デバッグ続行）

## Step 2：最小限の変更で検証

複雑な仮説を立てる前に：

1. **エラーメッセージやリダイレクト先を詳細に追跡**
2. **指定した値が正しく渡っているか確認**
3. **公式ドキュメントの例と比較**

## 技術選択の優先順位

1. **ブラウザネイティブAPI**（最も信頼性高い）
   - `window.location.href`, `localStorage`, `fetch`

2. **安定版フレームワークAPI**

3. **新しいフレームワークAPI**（バグの可能性あり）
   - 使用前にGitHub Issues確認必須

## 修正案提案時のプロセス

**修正案は複数比較検討してから提案する。**

1. **複数アプローチを列挙** - 最低2つ以上の解決策を考える
2. **トレードオフを評価** - 各アプローチの長所・短所を明確化
3. **堅牢性を優先** - 短期的に早くても壊れやすい解決策を避ける

### 優先順位

1. **イベント駆動** - コールバック、状態変更の検知
2. **宣言的状態管理** - フラグ、条件分岐
3. **タイミング依存** - `setTimeout`、`waitForTimeout`（最後の手段）

### setTimeoutの使用基準

**原則**: イベント駆動 > 宣言的状態 > タイミング依存

```typescript
// ✅ 理想: イベント駆動
onOpenChange={(open) => {
  if (!open && pending) setShowDialog(true)
}}

// ⚠️ 注意: 上記が機能しない場合のみsetTimeoutを検討
// 例: Radix UIのonOpenChangeはプログラム的なsetIsOpen()では発火しない
```

**setTimeoutが許容されるケース**:
1. イベントコールバックがライブラリの制約で発火しない
2. CSSアニメーション完了を待つ必要がある
3. 上記を公式ドキュメントで確認済み

**setTimeoutを使う場合の必須事項**:
```typescript
// ❌ マジックナンバー
setTimeout(() => setShowDialog(true), 300)

// ✅ 定数化 + 根拠をコメント
// SheetContentのクローズアニメーション（components/ui/sheet.tsx参照）
const SHEET_CLOSE_ANIMATION_MS = 300
setTimeout(() => setShowDialog(true), SHEET_CLOSE_ANIMATION_MS)
```

## 修正完了時の評価（必須）

**不具合修正が完了したら、以下の評価を行いユーザーに報告する。**

### 評価観点

| 観点 | 評価基準 |
|------|----------|
| **公式推奨** | フレームワーク/ライブラリの公式パターンか |
| **動作原理** | 正規のAPIか、シミュレート/ハックか |
| **将来互換性** | バージョン変更で壊れる可能性 |
| **実用性** | 問題を確実に解決するか |
| **採用実績** | 他のライブラリ/プロジェクトで採用されているか |

### 評価テンプレート

```markdown
## 修正評価

| 観点 | 評価 | 備考 |
|------|------|------|
| 公式推奨 | ✅/⚠️/❌ | |
| 動作原理 | ✅/⚠️/❌ | |
| 将来互換性 | ✅/⚠️/❌ | |
| 実用性 | ✅/⚠️/❌ | |
| 採用実績 | ✅/⚠️/❌ | |

**結論**: 正当な修正 / 実用的な回避策 / 応急処置

**より正当なアプローチ**（回避策の場合）:
1. [代替案1]
2. [代替案2]
```

### 評価結果の活用

- **正当な修正**: そのまま本番適用OK
- **実用的な回避策**: 本番適用可、ただしTODOコメントで将来の改善を記録
- **応急処置**: 早急に正当な修正への置き換えを計画

---

## アンチパターン

- ❌ 公式ドキュメントを確認せずに仮説を立てる
- ❌ 同じアプローチを3回以上繰り返す
- ❌ 複雑な解決策（新規ファイル作成、テンプレート修正等）から試す
- ❌ GitHub Issues検索を後回しにする
- ❌ ドキュメントの例を「単なる例」と解釈して自己流にアレンジする
- ❌ 最初に思いついた解決策をそのまま提案する
- ❌ `setTimeout`をトレードオフ説明なしに使用する

## デバッグの基本

1. 最小再現テストを作成
2. シンプルな解決策から試す
3. 手動リロードで動作確認 → キャッシュ問題の切り分け

## プロジェクト既知問題

[既知問題データベース](references/known-issues.md) を先に確認

---

## 既知の不具合パターンと解決策

### 1. Next.js useSearchParams レースコンディション

**症状**: `router.replace()` でURL更新後、React状態とURLが同期しない。UI表示が古い状態のまま。

**原因**: `router.replace()` は非同期でサーバーラウンドトリップ（200-500ms）を伴う。その間にReact状態は更新済みでも、`useSearchParams` の `useEffect` が遅れて発火し、古い状態に戻してしまう。

**解決策**: `pushState` + `PopStateEvent`

```typescript
const isUpdatingFromCode = useRef(false)

const updateState = useCallback((newState) => {
  isUpdatingFromCode.current = true  // フラグで逆同期を防止
  setState(newState)

  // 即時URL更新（サーバーラウンドトリップなし）
  window.history.pushState({ source: 'myHook' }, '', url)
  // Next.jsに通知
  window.dispatchEvent(new PopStateEvent('popstate', { state: { source: 'myHook' } }))
}, [])

useEffect(() => {
  if (isUpdatingFromCode.current) {
    isUpdatingFromCode.current = false
    return  // プログラムからの更新時はスキップ
  }
  setState(deserializeFromUrl(searchParams))
}, [searchParams])
```

**解決策の評価**:

| 観点 | 評価 | 備考 |
|------|------|------|
| Next.js公式推奨 | ❌ | 非公式パターン |
| 動作原理 | ⚠️ | ブラウザイベントのシミュレート |
| 将来互換性 | ⚠️ | Next.jsバージョン変更で壊れる可能性 |
| 実用性 | ✅ | 問題を確実に解決 |
| 採用実績 | ✅ | nuqs等のライブラリが同様のアプローチ |

**より正当なアプローチ**:
1. `nuqs` ライブラリ導入（URL状態管理専用、最も推奨）
2. React 19 `useOptimistic`（UI先行更新、公式パターン）
3. 状態とURLの分離（URLを「結果」として扱う設計）

**発見経緯**: Web検索で「router.replace async server round-trip」を検索し、Next.jsの動作仕様を確認。

**参照**: `hooks/use-event-search-state.ts`

---

### パターン追加テンプレート

```markdown
### N. [問題の短い説明]

**症状**: [ユーザーが観察する現象]

**原因**: [技術的な根本原因]

**解決策**: [コード例]

**解決策の評価**:
| 観点 | 評価 | 備考 |
|------|------|------|
| 公式推奨 | ✅/⚠️/❌ | |
| 将来互換性 | ✅/⚠️/❌ | |
| 実用性 | ✅/⚠️/❌ | |

**発見経緯**: [どのように解決に至ったか]
```
