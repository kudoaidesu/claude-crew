---
name: e2e-test-principles
description: E2Eテスト作成・修正・実行時の原則。test.skip()の正しい使い方、テストデータ準備の原則、フィルター/検索機能のデータ範囲一貫性チェックを提供。E2Eテスト作成、テスト失敗の修正、フィルター機能の実装・テスト時に使用。トリガーワード：「テストを書いて」「テスト追加」「E2Eテスト」「テストを作成」「テストを消化」「spec.tsを作成」「Playwrightテスト」「テストが落ちる」「テストを修正」「テストを通して」「デプロイ前テスト」「test:e2e」。
---

# E2Eテスト原則

## テスト実行前チェック（必須）

E2Eテスト実行前に以下を確認：

### 1. テストユーザー作成
```bash
npx tsx scripts/seed-test-users.ts
```

### 2. 開発サーバー起動確認
```bash
curl -s -o /dev/null -w "%{http_code}" http://localhost:3000
# 200が返ればOK
```

## よくある失敗パターン

| エラー | 原因 | 解決 |
|--------|------|------|
| 認証エラー（メールアドレスまたはパスワードが正しくありません） | テストユーザー未作成 | `npx tsx scripts/seed-test-users.ts` |
| ログアウトボタンが見つからない | /unauthorized等にログアウトUIがない | テスト目的達成済みならlogout()を省略 |
| toHaveBeenCalledWith不一致 | APIに新パラメータ追加 | テストの期待値を実装に合わせて更新 |
| 環境変数テスト失敗 | Jestで.env未読み込み | `process.env.CI === 'true'`で条件分岐 |

## スキップ条件の使い方

### 使うべき場面
- UIが本当に存在しない（404等）
- 外部サービスが利用不可
- 環境依存で実行不可能

### 使うべきでない場面
- データが不足している → **データを準備する**
- テスト対象の理解が不足 → **調査する**

## テスト失敗時のフロー

```
テスト失敗
  ↓
❌ スキップ条件を緩和してテストを通す
✅ 根本原因を調査 → テストが期待する状態を作る
```

## データ準備の原則

1. **UIの実際の表示順序を理解する**
   - DBのソート順とUI表示順は異なる場合がある
   - 例：団体一覧は名前順ではなく階層構造（種別→地域→市町村）

2. **seedスクリプトで必要なデータを準備する**
   ```typescript
   // ❌ DBソート順で最初の団体を取得
   const { data } = await supabase.from('groups').order('name').limit(1);

   // ✅ UI表示順で最初の団体を特定して使用
   const FIRST_DISPLAYED_GROUP_ID = 78; // 調査して特定
   ```

3. **テストは仕様を表現する**
   - テストを弱くすること = 仕様を曖昧にすること

## フィルター/検索機能のテスト設計

### データ範囲の一貫性を確認する

**原則**: UIで表示される範囲 = フィルター対象の範囲

```
❌ 問題パターン（今回の教訓）
- カレンダーUIは過去の日付も表示
- フィルターなし → 過去のカウントも表示
- フィルターあり → 過去のカウントが消える ← 不整合！
```

### チェックリスト

フィルター機能を実装・テストする際：

1. **表示範囲の確認**
   - UIで表示されるデータの時間範囲は？（過去/未来/全期間）
   - フィルター対象のデータソースは同じ範囲をカバーしているか？

2. **状態変化の一貫性テスト**
   ```typescript
   // ✅ フィルター適用前後で「表示されるべき範囲」が一致するか確認
   test('過去の日付もフィルター適用後にカウント表示される', async ({ page }) => {
     // 過去日付に移動
     await page.goto('/date/2025-12-14')
     // フィルター適用前のカウントを確認
     const beforeCount = await getEventCount(page, '2025-12-14')
     // フィルター適用
     await applyFilter(page, { groupType: 'traditional' })
     // 過去日付のカウントが0ではないことを確認（表示範囲の一貫性）
     const afterCount = await getEventCount(page, '2025-12-14')
     expect(afterCount).toBeGreaterThanOrEqual(0) // 消えていないことを確認
   })
   ```

3. **複数データソースの整合性**
   - 同じUI要素に対して異なるデータソースが使われていないか
   - 例：`eventCounts`（全期間）と `allUpcomingEvents`（今後のみ）を混在させない