---
name: skill-creator
description: 効果的なスキル作成ガイド。Claudeの機能を拡張する新しいスキルの作成（または既存スキルの更新）時に使用。専門知識、ワークフロー、ツール統合を追加。
license: Complete terms in LICENSE.txt
---

# スキルクリエイター

効果的なスキル作成のためのガイダンスを提供する。

## スキルについて

スキルは、専門知識、ワークフロー、ツールを提供してClaudeの機能を拡張するモジュール式の自己完結型パッケージ。特定のドメインやタスクのための「オンボーディングガイド」と考える。

### スキルが提供するもの

1. 専門的なワークフロー - 特定ドメイン向けの多段階手順
2. ツール統合 - 特定のファイル形式やAPIとの連携手順
3. ドメイン専門知識 - 企業固有の知識、スキーマ、ビジネスロジック
4. バンドルリソース - 複雑で反復的なタスク用のスクリプト、リファレンス、アセット

## コア原則

### 簡潔さが重要

コンテキストウィンドウは公共財。スキルはシステムプロンプト、会話履歴、他のスキルのメタデータ、ユーザーリクエストとコンテキストを共有する。

**デフォルトの前提：Claudeは既に非常に賢い。** Claudeがまだ持っていないコンテキストのみを追加。各情報に「Claudeはこの説明が本当に必要か？」「この段落はトークンコストに見合うか？」と問う。

冗長な説明より簡潔な例を優先。

### 適切な自由度を設定

タスクの脆弱性と変動性に応じて具体性のレベルを合わせる：

**高い自由度（テキストベースの指示）**: 複数のアプローチが有効、判断がコンテキストに依存、ヒューリスティクスがアプローチを導く場合。

**中程度の自由度（擬似コードまたはパラメータ付きスクリプト）**: 推奨パターンが存在、ある程度の変動が許容、設定が動作に影響する場合。

**低い自由度（特定のスクリプト、少ないパラメータ）**: 操作が脆弱でエラーが起きやすい、一貫性が重要、特定の順序に従う必要がある場合。

### スキルの構造

すべてのスキルは必須のSKILL.mdファイルとオプションのバンドルリソースで構成：

```
skill-name/
├── SKILL.md（必須）
│   ├── YAMLフロントマター（必須）
│   │   ├── name:（必須）
│   │   └── description:（必須）
│   └── Markdown指示（必須）
└── バンドルリソース（オプション）
    ├── scripts/          - 実行可能コード（Python/Bash等）
    ├── references/       - 必要に応じてコンテキストに読み込むドキュメント
    └── assets/           - 出力で使用するファイル（テンプレート、アイコン、フォント等）
```

#### SKILL.md（必須）

- **フロントマター**（YAML）：`name`と`description`フィールド。スキルがいつ使用されるかをClaudeが判断するために読む唯一のフィールド。
- **本文**（Markdown）：スキル使用のための指示とガイダンス。スキルがトリガーされた後にのみ読み込まれる。

#### バンドルリソース（オプション）

##### スクリプト（`scripts/`）

決定論的な信頼性が必要、または繰り返し書き直されるタスク用の実行可能コード。

- **含めるべき時**: 同じコードが繰り返し書き直される、決定論的な信頼性が必要
- **利点**: トークン効率的、決定論的、コンテキストに読み込まずに実行可能

##### リファレンス（`references/`）

必要に応じてコンテキストに読み込むドキュメントとリファレンス資料。

- **含めるべき時**: Claudeが作業中に参照すべきドキュメント
- **例**: DBスキーマ、APIドキュメント、ドメイン知識、会社ポリシー
- **ベストプラクティス**: 大きいファイル（>10k語）はSKILL.mdにgrep検索パターンを含める

##### アセット（`assets/`）

コンテキストに読み込む目的ではなく、Claudeが生成する出力内で使用するファイル。

- **含めるべき時**: 最終出力で使用するファイルが必要
- **例**: ブランドアセット、テンプレート、ボイラープレートコード、フォント

#### スキルに含めないもの

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md

スキルはAIエージェントが仕事をするために必要な情報のみを含むべき。

### プログレッシブディスクロージャ設計原則

スキルはコンテキストを効率的に管理するための3レベルの読み込みシステムを使用：

1. **メタデータ（name + description）** - 常にコンテキスト内（〜100語）
2. **SKILL.md本文** - スキルがトリガーされた時（<5k語）
3. **バンドルリソース** - Claudeが必要に応じて

SKILL.md本文はコンテキスト膨張を最小化するため500行以下に。この制限に近づいたらコンテンツを別ファイルに分割。

**パターン1：リファレンス付き高レベルガイド**

```markdown
# PDF処理

## クイックスタート

pdfplumberでテキスト抽出：
[コード例]

## 高度な機能

- **フォーム入力**: [FORMS.md](FORMS.md)を参照
- **APIリファレンス**: [REFERENCE.md](REFERENCE.md)を参照
```

**パターン2：ドメイン固有の構成**

```
bigquery-skill/
├── SKILL.md（概要とナビゲーション）
└── reference/
    ├── finance.md（収益、請求指標）
    ├── sales.md（商談、パイプライン）
    └── product.md（API使用、機能）
```

## スキル作成プロセス

1. 具体的な例でスキルを理解
2. 再利用可能なスキルコンテンツを計画（スクリプト、リファレンス、アセット）
3. スキルを初期化（init_skill.pyを実行）
4. スキルを編集（リソースを実装しSKILL.mdを記述）
5. スキルをパッケージ化（package_skill.pyを実行）
6. 実際の使用に基づいて反復

### ステップ1：具体的な例でスキルを理解

スキルの使用パターンが既に明確に理解されている場合のみスキップ。

効果的なスキルを作成するには、スキルがどのように使用されるかの具体例を明確に理解する。

### ステップ2：再利用可能なスキルコンテンツの計画

具体例を効果的なスキルに変えるため、各例を分析：

1. 例をゼロから実行する方法を検討
2. これらのワークフローを繰り返し実行する際に役立つスクリプト、リファレンス、アセットを特定

### ステップ3：スキルの初期化

新しいスキルをゼロから作成する際は、常に`init_skill.py`スクリプトを実行：

```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

スクリプトは：
- 指定パスにスキルディレクトリを作成
- 適切なフロントマターとTODOプレースホルダー付きのSKILL.mdテンプレートを生成
- サンプルリソースディレクトリを作成：`scripts/`、`references/`、`assets/`

### ステップ4：スキルを編集

スキルは別のClaudeインスタンスが使用するために作成される。別のClaudeインスタンスがこれらのタスクをより効果的に実行するのに役立つ手続き的知識、ドメイン固有の詳細、再利用可能なアセットを含める。

#### 証明されたデザインパターンを学ぶ

スキルのニーズに基づいてこれらのガイドを参照：

- **多段階プロセス**: references/workflows.mdを参照
- **特定の出力形式または品質基準**: references/output-patterns.mdを参照

#### SKILL.mdを更新

##### フロントマター

`name`と`description`でYAMLフロントマターを記述：

- `name`: スキル名
- `description`: スキルの主要なトリガーメカニズム。スキルが何をするか、いつ使うかの両方を含める。

##### 本文

スキルとそのバンドルリソースの使用手順を記述。

### ステップ5：スキルのパッケージ化

開発完了後、配布可能な.skillファイルにパッケージ化：

```bash
scripts/package_skill.py <path/to/skill-folder>
```

パッケージングスクリプトは：
1. スキルを**検証**（フロントマター形式、命名規則、説明の完全性等）
2. 検証に合格したらスキルを**パッケージ化**

### ステップ6：反復

スキルをテストした後、改善が要求される場合がある。

**反復ワークフロー：**

1. 実際のタスクでスキルを使用
2. 困難や非効率を認識
3. SKILL.mdまたはバンドルリソースの更新方法を特定
4. 変更を実装し再テスト
